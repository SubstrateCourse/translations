1
00:00:00,866 --> 00:00:02,399
Hello everyone, I am Kaichao
大家好 我是凯超

2
00:00:02,400 --> 00:00:03,933
The content of this lesson includes
本次课程内容是

3
00:00:04,500 --> 00:00:07,266
generic types, traits and lifetimes in Rust
Rust的泛型, trait和生命周期

4
00:00:09,000 --> 00:00:11,300
First we will introduce the concept of generic types
首先我们会介绍一下泛型的概念

5
00:00:11,800 --> 00:00:13,933
then how to use trait
接着是如何使用trait

6
00:00:14,133 --> 00:00:17,133
and the lifetime of variables and references
以及变量和引用的生命周期的使用

7
00:00:18,000 --> 00:00:19,900
So why use generic types?
那为什么要使用泛型呢

8
00:00:20,333 --> 00:00:22,366
In previous lessons we have mentioned that
我们之前的课程讲到过

9
00:00:23,000 --> 00:00:25,800
we can encapsulate modular code for code reuse
可以通过模块化的代码封装

10
00:00:25,800 --> 00:00:27,466
we can encapsulate modular code for code reuse
实现代码的复用

11
00:00:28,533 --> 00:00:29,899
For common used modules
一些公共的模块

12
00:00:29,900 --> 00:00:31,533
we can provide some interfaces
我们可以开放一些接口

13
00:00:31,533 --> 00:00:33,533
so that it can be used by other code
供其他的代码所使用

14
00:00:34,533 --> 00:00:37,266
There is a another way to reuse the shared code
还有另外一种形式的代码复用机制

15
00:00:37,266 --> 00:00:38,399
through generic types
就是通过泛型

16
00:00:38,766 --> 00:00:41,266
When data structures or functions are similar
当一些数据结构或者函数的功能

17
00:00:41,266 --> 00:00:42,166
When data structures or functions are similar
很类似时

18
00:00:42,166 --> 00:00:43,499
we can use generic types
可以使用泛型

19
00:00:44,166 --> 00:00:45,533
We'll look at some examples later
后面我们会看一些例子

20
00:00:46,566 --> 00:00:48,133
By abstracting with generic types
通过泛型这种抽象

21
00:00:48,133 --> 00:00:50,166
we can increase the extensibility of the code
我们可以增加代码的可扩展性

22
00:00:50,900 --> 00:00:53,066
When adding a new data structure
当我们新增了一个数据结构的时候

23
00:00:53,066 --> 00:00:55,299
we don't need to change the existing function
我们不需要改变已有的函数

24
00:00:55,300 --> 00:00:56,100
because
因为

25
00:00:56,800 --> 00:00:59,666
the current function may accept a parameter of generic type
当前的函数可能是接受一个泛型参数

26
00:00:59,666 --> 00:01:01,599
Then our new data structure only need to meet the constraints of this generic type
那我们新增的这个数据结构

27
00:01:01,599 --> 00:01:01,600
Then our new data structure only need to meet the constraints of this generic type

28
00:01:01,600 --> 00:01:02,124
Then our new data structure only need to meet the constraints of this generic type
只要满足这个泛型参数所对应的约束就可以了

29
00:01:02,124 --> 00:01:04,400
Then our new data structure only need to meet the constraints of this generic type
只要满足这个泛型参数所对应的约束就可以了

30
00:01:04,400 --> 00:01:05,200
Then our new data structure only need to meet the constraints of this generic type
只要满足这个泛型参数所对应的约束就可以了

31
00:01:06,533 --> 00:01:08,599
Generic types are often used in the definition of struct, enum and function signature
泛型常用于结构体的定义, 枚举定义和函数签名

32
00:01:08,599 --> 00:01:10,400
Generic types are often used in the definition of struct, enum and function signature
泛型常用于结构体的定义, 枚举定义和函数签名

33
00:01:11,800 --> 00:01:14,300
Now let's look at an example of struct
现在我们来看一个结构体的例子

34
00:01:14,666 --> 00:01:16,966
Here we define a struct called Point
这里我们定义了一个表示

35
00:01:17,966 --> 00:01:20,466
it represents a point on the coordinate system
坐标系上的一个点的结构体Point

36
00:01:20,966 --> 00:01:23,066
It has two attributes which are x, y
它有两个属性分别是x y

37
00:01:24,000 --> 00:01:26,733
here x, y can be an integer or float
那x y可以是整数 也可以是浮点数

38
00:01:26,733 --> 00:01:28,366
Now we can use generic type to reduce the definition of similar structs
这个时候我们就可以

39
00:01:28,366 --> 00:01:31,400
Now we can use generic type to reduce the definition of similar structs
通过泛型来减少类似的结构体定义

40
00:01:31,400 --> 00:01:32,733
Now we can use generic type to reduce the definition of similar structs
通过泛型来减少类似的结构体定义

41
00:01:33,133 --> 00:01:35,866
here we use an angle bracket
那我们是通过一个尖括号

42
00:01:35,866 --> 00:01:38,599
it contains a generic type T
里面包含一个泛型的参数T

43
00:01:38,933 --> 00:01:43,366
by convention we capitalize the letter to represent the generic type
约定俗成的 我们以大写的单字母来表示我们的泛型

44
00:01:43,366 --> 00:01:44,933
by convention we capitalize the letter to represent the generic type
约定俗成的 我们以大写的单字母来表示我们的泛型

45
00:01:44,933 --> 00:01:46,599
If it has only one generic type
如果是一个泛型参数的话

46
00:01:46,600 --> 00:01:47,866
we usually use T
我们通常使用T

47
00:01:49,066 --> 00:01:51,333
it is the first letter (T) of type
也就是type的首字母T

48
00:01:52,900 --> 00:01:55,666
Here we implement a function x for our struct
这里我们为我们的结构体实现了一个方法x

49
00:01:55,666 --> 00:01:57,966
Here we implement a function x for our struct
这里我们为我们的结构体实现了一个方法x

50
00:01:58,366 --> 00:02:01,966
Its parameter is a reference to the struct itself
它的参数是结构体自身的一个引用

51
00:02:02,000 --> 00:02:04,900
then returns a reference to T
那返回一个T的引用

52
00:02:05,700 --> 00:02:07,366
Note that
这里要注意我们在

53
00:02:07,800 --> 00:02:09,500
when implementing the corresponding struct
实现对应的结构体的时候

54
00:02:09,500 --> 00:02:11,866
after the keyword impl, we need to add the generic type T
我们在implement后面要加一个

55
00:02:11,866 --> 00:02:12,700
after the keyword impl, we need to add the generic type T

56
00:02:12,700 --> 00:02:15,166
after the keyword impl, we need to add the generic type T
在implement后面要指定我们的泛型T

57
00:02:16,366 --> 00:02:17,799
we also need to indicate it here if there are constraints to the generic type
如果有泛型约束的话 我们也要添加在对应的后面

58
00:02:17,799 --> 00:02:19,733
we also need to indicate it here if there are constraints to the generic type
如果有泛型约束的话 我们也要添加在对应的后面

59
00:02:20,566 --> 00:02:23,866
The logic of the x method here is very simple
这里x方法的逻辑很简单就是获取

60
00:02:24,400 --> 00:02:26,266
it gets the field x of the struct
当前结构体的x

61
00:02:27,166 --> 00:02:29,099
and returns a reference to x
属性并且返回它的引用

62
00:02:29,900 --> 00:02:30,266
Let's look at the main function
可以看到

63
00:02:30,266 --> 00:02:32,499
Let's look at the main function
当我们在main函数里面可以定义

64
00:02:33,133 --> 00:02:35,966
we can define a point where x and y are integer
x y分别是整数的这样的一个point结构体

65
00:02:36,166 --> 00:02:39,866
we can also define a point where x and y are float number
也可以定义x y是浮点数对应的结构体float

66
00:02:39,866 --> 00:02:39,933
we can also define a point where x and y are float number
也可以定义x y是浮点数对应的结构体float

67
00:02:39,933 --> 00:02:41,366
we can also define a point where x and y are float number
也可以定义x y是浮点数对应的结构体float

68
00:02:43,400 --> 00:02:45,133
Let's look at another example for enum
我们再来看一个枚举的例子

69
00:02:45,133 --> 00:02:47,499
In the previous lesson we mentioned that
我们之前课程中讲到过

70
00:02:47,800 --> 00:02:49,200
there are two important enums
两个重要的枚举

71
00:02:49,200 --> 00:02:53,666
One is Option, represents containing a value or None
一个是Option 表示有值或者无值

72
00:02:53,700 --> 00:02:54,666
If containing a value
那有值的话

73
00:02:54,666 --> 00:02:57,333
the type of the value can be integer, float, string etc.
这个值的类型我们可以是整数, 可以是浮点数, 可以字符串, 等等

74
00:02:57,333 --> 00:02:59,899
the type of the value can be integer, float, string etc.
这个值的类型我们可以是整数, 可以是浮点数, 可以字符串, 等等

75
00:03:00,100 --> 00:03:01,866
Here we can use generic type T for abstraction
那我们这里就可以用一个泛型T进行抽象

76
00:03:01,866 --> 00:03:03,466
Here we can use generic type T for abstraction
那我们这里就可以用一个泛型T进行抽象

77
00:03:04,666 --> 00:03:07,866
it makes our code more extensible and flexible
让我们的代码可扩展性更强也更灵活

78
00:03:08,133 --> 00:03:10,733
Similarly, for the Result enum
那同样的我们的Result类型

79
00:03:10,900 --> 00:03:12,266
it has two generic types, T and E
它有两个泛型参数

80
00:03:12,266 --> 00:03:14,133
separated by comma
通过逗号进行分割

81
00:03:14,466 --> 00:03:16,066
the first generic type parameter T represents the type of a value in correct cases
第一个泛型参数表示正确的情况下 值的类型

82
00:03:16,066 --> 00:03:18,699
the first generic type parameter T represents the type of a value in correct cases
第一个泛型参数表示正确的情况下 值的类型

83
00:03:18,800 --> 00:03:20,166
The second parameter E represents the type of error information in error cases
那第二个参数E 表示错误场景下的错误类型

84
00:03:20,166 --> 00:03:23,499
The second parameter E represents the type of error information in error cases
那第二个参数E 表示错误场景下的错误类型

85
00:03:25,800 --> 00:03:27,333
Now let's look at an example
现在我们来看一个

86
00:03:27,333 --> 00:03:30,499
that generic type is used in function signatures
泛型参数用在函数签名里的例子

87
00:03:31,133 --> 00:03:33,599
Here we define a function largest
这里我们定义了一个函数largest

88
00:03:34,266 --> 00:03:36,533
It takes a parameter called list
它接收一个参数list

89
00:03:36,866 --> 00:03:40,099
its type is a reference to a vector
它的类型是集合类型的引用

90
00:03:41,100 --> 00:03:42,466
the logic is pretty simple
它的逻辑很简单

91
00:03:42,466 --> 00:03:45,399
It will get the maximum value in the vector
就是取得当前集合里面的最大值

92
00:03:45,400 --> 00:03:47,700
and returns a reference of the value
并且返回该值的引用

93
00:03:49,000 --> 00:03:52,500
Such a function can be used to calculate the maximum value of a vector of integers
这样一个函数可以去计算整数集合的最大值

94
00:03:52,500 --> 00:03:54,100
or a vector of characters
也可以去计算字符集合的最大值

95
00:03:54,100 --> 00:03:56,399
or a vector of characters
也可以去计算字符集合的最大值

96
00:03:56,666 --> 00:04:00,566
as long as the type inside the vector can be compared with each other
只要是里面的类型是可以比较大小的

97
00:04:00,566 --> 00:04:02,899
then our function should be able to apply to such vectors
那我们这个函数都可以来应用

98
00:04:03,766 --> 00:04:05,866
and calculate the maximum value in it
计算对应集合里面的最大值

99
00:04:08,000 --> 00:04:09,733
Now let's look at the code
现在我们来看一下代码演示

100
00:04:11,533 --> 00:04:13,666
First let's define the function largest
首先我们定义了函数largest

101
00:04:13,666 --> 00:04:15,466
First let's define the function largest
函数largest

102
00:04:15,866 --> 00:04:17,166
the parameter is a reference to a vector
它的参数我们刚才提到了

103
00:04:17,166 --> 00:04:19,933
the parameter is a reference to a vector
它是某个集合类型的引用

104
00:04:20,400 --> 00:04:23,900
returns a reference to an element in the vector
返回一个集合里面元素的引用

105
00:04:25,200 --> 00:04:27,933
First it takes the first element of the input vector
首先我们取当前集合第一个元素

106
00:04:28,700 --> 00:04:31,466
assign it to a mutable variable called largest
赋值给一个可变变量largest

107
00:04:32,733 --> 00:04:35,466
Then it loops through each element in the vector
接着我们循环集合里面的每一个元素

108
00:04:35,766 --> 00:04:40,766
compares the current element with the largest variable
将循环当前的元素与我们保存的临时

109
00:04:40,766 --> 00:04:41,333
compares the current element with the largest variable

110
00:04:41,333 --> 00:04:43,266
compares the current element with the largest variable
最大变量largest进行比较

111
00:04:43,266 --> 00:04:46,266
If the current element is larger than the largest
如果是当前元素大于largest的话

112
00:04:46,266 --> 00:04:47,933
we will update the largest to be the current element
我们将largest更新

113
00:04:48,666 --> 00:04:51,699
When finishing the loop, the largest is returned
循环完成之后我们将largest返回

114
00:04:53,966 --> 00:04:55,899
Then in the main function
我们在main函数里面

115
00:04:57,100 --> 00:04:58,400
we define a vector of integers called number_list
紧接着我们在main函数里面

116
00:04:58,400 --> 00:05:00,866
we define a vector of integers called number_list
定义了一个整数集合 number_list

117
00:05:00,866 --> 00:05:03,966
we define a vector of integers called number_list
定义了一个整数集合 number_list

118
00:05:04,133 --> 00:05:07,166
then call the function largest and passes in a reference to the vector
我们调用largest函数 传入我们整数集合的引用

119
00:05:08,100 --> 00:05:09,366
gets the result
然后返回结果

120
00:05:09,800 --> 00:05:11,000
print it
将结果进行打印

121
00:05:11,000 --> 00:05:13,000
Let's take a look at the result
我们来看一下打印的结果

122
00:05:14,466 --> 00:05:16,566
We can see there is a compilation error here
可以看到我们这里有一个编译错误

123
00:05:17,500 --> 00:05:19,900
that's because inside our largest function
那是因为我们的largest函数里面

124
00:05:20,266 --> 00:05:21,666
we need to compare elements in the vector
需要进行比较大小

125
00:05:21,766 --> 00:05:23,466
so the generic type T needs to have the capability to compare with each other
那我们的泛型参数T应该有一个比较大小的功能

126
00:05:23,466 --> 00:05:25,666
so the generic type T needs to have the capability to compare with each other
那我们的泛型参数T应该有一个比较大小的功能

127
00:05:25,933 --> 00:05:27,599
Here we can use trait bound for the constraints
我们可以通过trait bound来进行对应的约束

128
00:05:27,599 --> 00:05:29,266
Here we can use trait bound for the constraints
我们可以通过trait bound来进行对应的约束

129
00:05:29,466 --> 00:05:30,866
The compiler alreadly reminds us
这里边已经给了我们提示

130
00:05:30,866 --> 00:05:32,099
we need a constraint called PartialOrd
我们需要PartialOrd这样的一个约束

131
00:05:32,099 --> 00:05:35,066
we need a constraint called PartialOrd
我们需要PartialOrd这样的一个约束

132
00:05:36,600 --> 00:05:37,566
Details of trait bound will be introduced in the following content.
具体trait bound内容

133
00:05:37,566 --> 00:05:39,666
Details of trait bound will be introduced in the following content.
我们会在后面的课程进行介绍

134
00:05:41,933 --> 00:05:43,133
recompile
然后我们重新编译

135
00:05:44,600 --> 00:05:45,066
At this time, our results have been printed correctly
可以看到

136
00:05:45,066 --> 00:05:46,666
At this time, our results have been printed correctly
这时候我们的结果已经正常打印

137
00:05:46,666 --> 00:05:49,499
the max value is 100
它最大值是100, 没有问题

138
00:05:50,600 --> 00:05:53,166
Similarly, we can also compare a vector of characters
类似的我们还可以去比较一个

139
00:05:53,166 --> 00:05:54,766
Similarly, we can also compare a vector of characters
字符集合的大小

140
00:05:54,766 --> 00:05:55,300
Similarly, we can also compare a vector of characters

141
00:05:55,300 --> 00:05:57,933
to get the max character in it
来取得字符集合的最大值

142
00:05:58,966 --> 00:06:00,866
Here let's define a vector of characters called char_list
这里我们定义了一个字符集合char_list

143
00:06:01,500 --> 00:06:03,666
then call the function largest
然后我们调用largest这个函数

144
00:06:03,666 --> 00:06:04,499
pass in a reference to the vector
传入这个集合

145
00:06:04,500 --> 00:06:06,566
get the result and print it
获取结果并且打印

146
00:06:06,566 --> 00:06:08,133
You can see our largest character is y
可以看到我们最大的char的话

147
00:06:08,133 --> 00:06:09,133
You can see our largest character is y
应该是一个y

148
00:06:09,700 --> 00:06:11,400
Let's take a look at the results of the execution
我们来看一下执行的结果

149
00:06:12,066 --> 00:06:14,099
the result is expected
可以看到我们的执行结果也是正确的

150
00:06:14,866 --> 00:06:15,766
Through this example you can see
那通过这个例子的话

151
00:06:15,766 --> 00:06:16,966
Through this example you can see
大家就可以明显的看到

152
00:06:16,966 --> 00:06:19,799
how we use generic types to reduce duplicated code and reuse the logic
我们通过使用泛型可以减少我们的代码

153
00:06:19,799 --> 00:06:22,066
how we use generic types to reduce duplicated code and reuse the logic
实现我们代码复用

154
00:06:23,700 --> 00:06:26,133
There are several tips when using generic types
在使用泛型时有几个注意的点

155
00:06:26,300 --> 00:06:28,666
The first is abount benefit
第一个是使用泛型的好处

156
00:06:28,866 --> 00:06:29,499
using generic types in Rust will not affect the efficiency of code execution
Rust泛型

157
00:06:29,500 --> 00:06:32,300
using generic types in Rust will not affect the efficiency of code execution
并不会影响代码的执行效率

158
00:06:32,366 --> 00:06:33,399
This is because generic types are replaced by the concrete type at compile
这是因为泛型会在编译器编译期间替换为具体的类型

159
00:06:33,399 --> 00:06:36,499
This is because generic types are replaced by the concrete type at compile
这是因为泛型会在编译器编译期间替换为具体的类型

160
00:06:36,499 --> 00:06:38,366
This is because generic types are replaced by the concrete type at compile
这是因为泛型会在编译器编译期间替换为具体的类型

161
00:06:39,200 --> 00:06:40,366
Another tip worth noting is that
另外一个需要注意的是

162
00:06:40,366 --> 00:06:41,733
when your code has a lot of generic types, it will reduce the readability of the code
当你的代码里有非常多的泛型

163
00:06:41,733 --> 00:06:45,266
when your code has a lot of generic types, it will reduce the readability of the code
那代码的可读性会降低

164
00:06:45,900 --> 00:06:47,066
When you have a function with many generic types in the signature
当你某个函数的签名里面

165
00:06:47,066 --> 00:06:48,733
When you have a function with many generic types in the signature
有很多泛型的时候

166
00:06:48,733 --> 00:06:49,899
This usually means that your code needs to be refactored
这说明你的代码

167
00:06:49,899 --> 00:06:51,866
This usually means that your code needs to be refactored
需要进行一个合理的重构

168
00:06:53,366 --> 00:06:55,766
Next, let's take a look at trait in Rust
接着我们来看一下Rust里面的traits

169
00:06:56,566 --> 00:06:59,866
A trait abstracts a certain capability or behavior
一个trait抽象了某种功能或者行为

170
00:07:00,000 --> 00:07:02,266
it tells the compiler that some type can implement such capabilities
它告诉编译器这个类型

171
00:07:02,266 --> 00:07:03,799
it tells the compiler that some type can implement such capabilities
可以实现这样的功能

172
00:07:04,900 --> 00:07:08,533
Different types can have same capabilities by implementing the same trait
那不同的类型都可以去具有这种行为

173
00:07:08,533 --> 00:07:09,700
Different types can have same capabilities by implementing the same trait
或者功能

174
00:07:09,700 --> 00:07:11,200
For example, the capability to calculate the area
比如说计算面积的功能

175
00:07:11,200 --> 00:07:13,533
a square can calculate its area, so does triangle
正方形可以有 三角形也可以有

176
00:07:14,600 --> 00:07:17,700
Such a concept in Java is defined with interface
在Java里面这样的一个概念是通过

177
00:07:17,700 --> 00:07:20,000
Such a concept in Java is defined with interface
接口interface来实现的

178
00:07:21,400 --> 00:07:23,533
Here let's look at the definition of trait
这里我们来看一下trait定义

179
00:07:23,966 --> 00:07:26,566
We defined a trait named Summary
我们定义了一个trait 名字叫Summary

180
00:07:26,800 --> 00:07:29,000
we use the pub keyword to make it visible to others
可以看到我们使用pub关键字来对外可见

181
00:07:29,000 --> 00:07:33,200
In the case of trait Summary, there is a method called summarize
那summary的话有一个方法是summarize

182
00:07:33,600 --> 00:07:35,333
it does not have a default implementation
它没有一个默认的实现

183
00:07:35,500 --> 00:07:37,933
That is to say, the type that implement the summary trait must implement the method summarize
也就是说实现Summary trait的类型

184
00:07:37,933 --> 00:07:41,066
That is to say, the type that implement the summary trait must implement the method summarize
必须要实现summarize这样的方法

185
00:07:41,900 --> 00:07:43,333
Another scenario is
另外一种情况是

186
00:07:43,700 --> 00:07:45,900
we defined a trait named Summary
同样的我们定义了Summary这样一个trait

187
00:07:46,066 --> 00:07:47,299
but we give a default implementation to the summarize method
但是我们给

188
00:07:47,299 --> 00:07:50,266
but we give a default implementation to the summarize method
summarize这个函数定义了一个默认实现

189
00:07:50,866 --> 00:07:54,399
For the type that implements the Summary trait
那实现Summary trait的类型

190
00:07:54,666 --> 00:07:56,466
if such type want to use the default implementation
如果这样的类型是希望使用默认实现的话

191
00:07:56,466 --> 00:07:57,466
if such type want to use the default implementation
如果这样的类型是希望使用默认实现的话

192
00:07:57,466 --> 00:08:00,399
then it doesn't need to implement the summarize method by itself
那他就不需要去实现summarize这个方法

193
00:08:02,700 --> 00:08:05,700
We can combine generic types and traits together
我们可以把泛型和trait结合起来

194
00:08:06,100 --> 00:08:08,066
the the generic can have some constraints
从而让泛型有了某种约束

195
00:08:08,300 --> 00:08:08,933
that is to say
也就是说

196
00:08:08,933 --> 00:08:10,866
only generics that satisfy these constraints can be used
满足这些约束的类型才可以使用

197
00:08:10,866 --> 00:08:11,555
only generics that satisfy these constraints can be used
而不是接受任意的类型

198
00:08:11,555 --> 00:08:13,166
rather than accepting any concrete type
而不是接受任意的类型

199
00:08:14,066 --> 00:08:14,966
In other words
换句话说就是

200
00:08:14,966 --> 00:08:17,799
when the compiler tries to replace the generic type with a concrete type
当编译器尝试去替换泛型时

201
00:08:18,300 --> 00:08:20,466
the concrete type must have the capability defined by this trait
这个具体的类型必须有

202
00:08:20,466 --> 00:08:22,733
the concrete type must have the capability defined by this trait
这个trait定义的功能或者行为

203
00:08:22,733 --> 00:08:23,299
more specifically, the concrete type implements this trait
也就是说

204
00:08:23,299 --> 00:08:25,766
more specifically, the concrete type implements this trait
这个具体类型实现了这个trait

205
00:08:27,100 --> 00:08:28,966
Here let's look at an example
这里我们来看一个例子

206
00:08:28,966 --> 00:08:31,466
It defines a struct called Tweet
我们定义的一个结构体是Tweet

207
00:08:31,933 --> 00:08:34,866
which has two attributes, one is author and the other is text
它有两个属性 一个是author 一个是text

208
00:08:34,866 --> 00:08:36,366
both are string type
它都是string类型

209
00:08:37,600 --> 00:08:39,733
Let's implement the Summary trait we defined earlier for Tweet
那我们对Tweet

210
00:08:39,733 --> 00:08:41,533
Let's implement the Summary trait we defined earlier for Tweet
实现了我们之前定义的summary

211
00:08:41,533 --> 00:08:42,666
Let's implement the Summary trait we defined earlier for Tweet
这样的一个接口

212
00:08:43,700 --> 00:08:46,666
To implement the summarize function, we combine the content of author and text
那对应的summarize方法的实现

213
00:08:46,666 --> 00:08:48,466
To implement the summarize function, we combine the content of author and text
就是将两个

214
00:08:48,466 --> 00:08:51,266
To implement the summarize function, we combine the content of author and text
将Tweet里面两个属性的内容进行拼接

215
00:08:51,266 --> 00:08:52,533
return a string
返回一个string

216
00:08:54,133 --> 00:08:56,399
Then we define another function called notify
我们又定义了一个函数叫notify

217
00:08:57,000 --> 00:08:58,866
it receives a parameter called item
它接收一个参数是item

218
00:08:59,000 --> 00:09:01,466
item is an reference to a generic type T
它的类型是一个泛型的引用

219
00:09:02,066 --> 00:09:04,133
this generic type has a constraint that it must implement the Summary trait
这个泛型有一个约束是

220
00:09:04,133 --> 00:09:07,399
this generic type has a constraint that it must implement the Summary trait
它必须要满足Summary这样的一个trait

221
00:09:08,266 --> 00:09:09,466
The implementation here is very simple
里面的实现很简单

222
00:09:09,466 --> 00:09:13,299
we just print out the result of the summarize function
我们只是打印summarize方法的结果

223
00:09:14,500 --> 00:09:15,166
You can see that we're using a colon to identify the constraint
可以看到

224
00:09:15,166 --> 00:09:17,766
You can see that we're using a colon to identify the constraint
这里我们是通过冒号Summary来

225
00:09:17,766 --> 00:09:19,733
You can see that we're using a colon to identify the constraint
进行接口的约束

226
00:09:19,966 --> 00:09:20,999
which is usually called trait bound
也就是trait bound

227
00:09:21,933 --> 00:09:24,799
When the constraints are simple
当我们的约束比较简单的时候

228
00:09:24,800 --> 00:09:26,766
we can use the form of "impl Summary" to do so
我们可以去使用

229
00:09:26,933 --> 00:09:29,199
we can use the form of "impl Summary" to do so
impl Summary这样的形式

230
00:09:29,600 --> 00:09:30,766
If the trait bound is complex
如果接口比较复杂

231
00:09:30,766 --> 00:09:32,133
or it has multiple generic parameters
或者说有多个泛型参数的时候

232
00:09:32,133 --> 00:09:32,700
or it has multiple generic parameters
或者说有多个泛型参数的时候

233
00:09:32,700 --> 00:09:33,700
or it has multiple generic parameters
或者说有多个泛型参数的时候

234
00:09:33,700 --> 00:09:36,300
such form becomes less readable, we'll introduce another way for trait bound later
这种方式就会变得不易读

235
00:09:37,766 --> 00:09:39,699
Now let's write some code together
现在我们来一起写一下代码

236
00:09:41,366 --> 00:09:41,666
First
首先

237
00:09:41,666 --> 00:09:44,066
let's define a trait called Summary
我们定义了Summary这样的一个trait

238
00:09:44,100 --> 00:09:46,400
it has a function called summarize
它有一个方法summarize

239
00:09:46,400 --> 00:09:47,866
and it has no default implementation for summarize function
并且它没有默认的实现

240
00:09:49,900 --> 00:09:51,700
Next we define a strucl called Tweet
接着我们定义结构体

241
00:09:51,700 --> 00:09:52,666
Next let's define a struct called Tweet
以及

242
00:09:53,333 --> 00:09:55,999
and implement the Summary trait for the struct
结构体对Summary接口的实现

243
00:09:57,600 --> 00:09:59,000
The struct name is Tweet
结构体的名字是Tweet

244
00:09:59,200 --> 00:10:00,600
which is what we just saw
就是我们刚才看到的

245
00:10:01,733 --> 00:10:04,533
Let's define the function notify
我们再定义函数notify

246
00:10:04,600 --> 00:10:06,566
it prints out the results of our summarize function
打印summarize的结果

247
00:10:07,933 --> 00:10:09,466
Then we can use notify in the main function
接着我们就可以在

248
00:10:09,466 --> 00:10:11,466
Then we can use notify in the main function
main函数里面进行使用

249
00:10:11,466 --> 00:10:12,699
Then we can use notify in the main function
我们的notify函数

250
00:10:14,000 --> 00:10:16,133
First let's create an instance of Tweet
首先我们定义了一个

251
00:10:16,133 --> 00:10:18,266
First let's create an instance of Tweet
Tweet结构体的实例

252
00:10:18,733 --> 00:10:22,199
Its author is kaichao, and the text is "hello world"
它的author是kaichao, 它的text是hello world

253
00:10:22,500 --> 00:10:24,366
then let's call the notify function
那我们调用notify函数

254
00:10:24,366 --> 00:10:26,366
pass in a reference of the tweet that we just created
传入我们tweet的引用

255
00:10:27,733 --> 00:10:29,133
run the program
我们尝试运行

256
00:10:30,066 --> 00:10:31,733
it has printed the output we want
可以看到他现在

257
00:10:31,733 --> 00:10:32,133
it has printed the output we want

258
00:10:32,133 --> 00:10:34,733
it has printed the output we want
已经打印了我们想要的输出结果

259
00:10:36,200 --> 00:10:37,300
Here we can see
这里可以看到

260
00:10:37,366 --> 00:10:39,933
using trait bound has some great advantages
我们使用trait bound的好处是

261
00:10:40,500 --> 00:10:42,566
One is that function can accept generic parameters that we wouldn't bother to decide it now
我们可以接收一个

262
00:10:43,100 --> 00:10:45,166
One is that function can accept generic parameters that we wouldn't bother to decide it now
具有某种功能的泛型参数

263
00:10:45,500 --> 00:10:46,600
One is that function can accept generic parameters that we wouldn't bother to decide it now
而这个参数的话

264
00:10:46,600 --> 00:10:48,733
One is that function can accept generic parameters that we wouldn't bother to decide it now
我们是不用现在去确定

265
00:10:48,733 --> 00:10:50,066
the compiler will decide it for us when needed
编译器会把我们替换

266
00:10:50,133 --> 00:10:52,533
the function can not only accept a Tweet struct type, but also other types
我们不仅可以接受一个Tweet类型

267
00:10:52,533 --> 00:10:54,599
the function can not only accept a Tweet struct type, but also other types
也可以接受其他的类型

268
00:10:54,600 --> 00:10:56,100
as long as such types implement the Summary trait
只要他能够实现

269
00:10:56,100 --> 00:10:58,733
as long as such types implement the Summary trait
满足Summary这样的一个接口就可以了

270
00:11:01,000 --> 00:11:02,933
Another benefit of using trait bound is that
trait bound另外一个好处是

271
00:11:02,933 --> 00:11:04,699
when we have multiple parameters
当我们有多个参数时

272
00:11:04,900 --> 00:11:06,600
trait bound guarantees that parameters can be the same type
使用trait bound 可以保证

273
00:11:06,600 --> 00:11:08,700
trait bound guarantees that parameters can be the same type
参数类型是一致的

274
00:11:08,700 --> 00:11:11,100
For example, here the notify function takes two parameters
比如这里我们notify函数有两个参数

275
00:11:11,100 --> 00:11:12,700
one is item1, the other is item2
一个是item1

276
00:11:12,700 --> 00:11:13,933
one is item1, the other is item2
一个是item2

277
00:11:14,300 --> 00:11:18,133
Each of the parameters is a reference to generic type T
那这两个参数类型是泛型T的引用

278
00:11:18,966 --> 00:11:21,066
generic type T must satisfy the constraint identified by Summary trait
泛型T要满足Summary这样一个约束

279
00:11:22,266 --> 00:11:24,766
You can see that item1 and item2 have the same data type
可以看到item1和item2

280
00:11:24,766 --> 00:11:27,099
You can see that item1 and item2 have the same data type
两个数据类型是一致的

281
00:11:27,266 --> 00:11:30,099
During compiling, the generic type will be replaced by the final concrete data type
在编译器编译完成之后最终

282
00:11:30,099 --> 00:11:33,100
During compiling, the generic type will be replaced by the final concrete data type
会被替换为最终的一个数据类型

283
00:11:35,533 --> 00:11:38,699
Use "+" between each constraint When a generic type has multiple constraints
当某个泛型参数有多个类型约束时

284
00:11:38,699 --> 00:11:40,166
Use "+" between each constraint When a generic type has multiple constraints
可以使用加号

285
00:11:40,733 --> 00:11:42,399
For example
比如这里我们的

286
00:11:42,566 --> 00:11:45,399
here generic type T has two constraints, one is the trait Summary
泛型T除了有Summary接口的一个约束

287
00:11:45,400 --> 00:11:47,100
the other is the trait Display
还有Display接口的一个约束

288
00:11:47,500 --> 00:11:50,300
Display is a build-in trait defined in Rust standard library
Display是Rust内置的一个trait

289
00:11:50,466 --> 00:11:52,899
it's used to format the user-facing output
可以用来实现打印的功能

290
00:11:54,400 --> 00:11:56,600
Next, let's take a look at the use of the where keyword
接着我们来看一下where关键字的使用

291
00:11:56,700 --> 00:11:58,966
Here we have defined a function called some_function
这里我们定义了一个函数叫some_function

292
00:11:59,533 --> 00:12:02,066
it has two parameters, one is t and the other is u
它有两个参数一个是t 一个是u

293
00:12:02,300 --> 00:12:04,100
param t is a reference to the generic type T, param u is a reference to the generic type U
类型分别是泛型T的引用

294
00:12:04,100 --> 00:12:05,866
param t is a reference to the generic type T, param u is a reference to the generic type U
和泛型U的引用

295
00:12:06,466 --> 00:12:08,733
We can tell that the generic type T has two constraints
那可以看到泛型T有

296
00:12:08,733 --> 00:12:10,100
We can tell that the generic type T has two constraints
两个trait的约束

297
00:12:10,100 --> 00:12:11,600
generic type U also has two constraints
泛型U也有两个

298
00:12:12,566 --> 00:12:15,099
The signature of our function is really long and hard to read
函数签名比较长 可读性比较低

299
00:12:15,533 --> 00:12:18,533
Now let's use the where keyword to refactor our code
接着我们用where关键字进行改造

300
00:12:19,066 --> 00:12:20,333
some_function still has two parameters t and u
我们定义的some_function

301
00:12:20,333 --> 00:12:22,933
some_function still has two parameters t and u
这样为函数也是有两个参数t和u

302
00:12:23,466 --> 00:12:24,266



303
00:12:24,933 --> 00:12:27,199
and generic type T and U
对应的泛型T和泛型U的约束

304
00:12:27,266 --> 00:12:29,533
here we use the keyword "where" at the end of the function signature
在函数签名之后

305
00:12:29,533 --> 00:12:31,399
here we use the keyword "where" at the end of the function signature
我们通过在where关键字

306
00:12:31,533 --> 00:12:33,166
followed by the corresponding constraints of T and U
后面加上对应的

307
00:12:33,166 --> 00:12:35,066
followed by the corresponding constraints of T and U
T和U的泛型约束

308
00:12:35,200 --> 00:12:37,300
and separate multiple generic parameters by comma
并且通过逗号分隔多个泛型参数

309
00:12:37,300 --> 00:12:38,266
and separate multiple generic parameters by comma
并且通过逗号分隔多个泛型参数

310
00:12:38,266 --> 00:12:39,866
and separate multiple generic parameters by comma
并且通过逗号分隔多个泛型参数

311
00:12:42,266 --> 00:12:43,599
Next let's see the usage of lifetime
现在我们来看一下

312
00:12:43,599 --> 00:12:45,200
Next let's see the usage of lifetime
Rust里面的生命周期

313
00:12:45,800 --> 00:12:48,466
In rust, every variable has a lifetime
在Rust里每个变量都有生命周期

314
00:12:48,733 --> 00:12:51,933
lifetime is used to identify the validity or scope of a variable
生命周期指的是该变量的有效范围

315
00:12:51,933 --> 00:12:53,366
lifetime is used to identify the validity or scope of a variable
或者说是它的作用域

316
00:12:53,366 --> 00:12:56,066
lifetime is used to identify the validity or scope of a variable
那生命周期的英文是lifetime

317
00:12:56,066 --> 00:12:56,700
The advantage of using lifetime is that it ensures the references are valid and prevents null pointers

318
00:12:56,700 --> 00:12:59,300
The advantage of using lifetime is that it ensures the references are valid and prevents null pointers
生命周期的好处是它确保了引用的有效性

319
00:12:59,300 --> 00:13:00,700
The advantage of using lifetime is that it ensures the references are valid and prevents null pointers
生命周期的好处是它确保了引用的有效性

320
00:13:00,700 --> 00:13:03,566
The advantage of using lifetime is that it ensures the references are valid and prevents null pointers
来防止我们代码里面出现空指针

321
00:13:04,200 --> 00:13:06,100
Let's look at a code snippet
这里我们看一个代码片段

322
00:13:07,066 --> 00:13:09,066
It defines a variable r
我们定义了一个变量r

323
00:13:09,800 --> 00:13:11,366
then we use curly braces to create a new scope
接着我们用大括号生成了一个新的作用域

324
00:13:11,366 --> 00:13:12,866
then we use curly braces to create a new scope
接着我们用大括号生成了一个新的作用域

325
00:13:13,166 --> 00:13:16,899
Inside the braces we define a variable x
在大括号里面我们定义了一个变量x

326
00:13:16,900 --> 00:13:18,000
the value is 5
它的值是5

327
00:13:18,800 --> 00:13:19,600
then the reference of x is assigned to our variable r defined in the outer scope
我们将对应x的引用赋值给外层的变量r

328
00:13:19,600 --> 00:13:23,066
then the reference of x is assigned to our variable r defined in the outer scope
我们将对应x的引用赋值给外层的变量r

329
00:13:23,766 --> 00:13:25,899
when x goes out of scope
然后退出我们当前x作用域

330
00:13:27,066 --> 00:13:28,766
let's try to print the value referenced by r
尝试打印r引用的值

331
00:13:29,566 --> 00:13:31,799
we will get a compilation error at current stage
这个时候会报编译异常

332
00:13:31,933 --> 00:13:33,799
The reason is that the scope of r is the outer curly braces
原因是我们的

333
00:13:33,799 --> 00:13:37,166
The reason is that the scope of r is the outer curly braces
r的作用域是在最外层的这个大括号

334
00:13:37,200 --> 00:13:40,300
and the scope of x is the inner curly braces
而x的作用域是在内层的大括号

335
00:13:40,900 --> 00:13:44,700
The compiler checks the validity of references at compile time
编译器在编译时会检查引用的有效性

336
00:13:45,100 --> 00:13:46,266
it detected that r try to reference a value whose scope is smaller than its own scope
他检测到

337
00:13:46,266 --> 00:13:47,700
it detected that r try to reference a value whose scope is smaller than its own scope
r尝试引用

338
00:13:47,700 --> 00:13:50,066
it detected that r try to reference a value whose scope is smaller than its own scope
一个比自己更小的一个作用域

339
00:13:50,066 --> 00:13:51,666
and raise the above compiling error
那就会抛出相应的异常

340
00:13:53,700 --> 00:13:55,933
Now let's look at the lifetime of references
现在我们来看一下引用的生命周期

341
00:13:56,166 --> 00:13:59,166
most of the time lifetime is implicit
在大多数时候生命周期都是隐含的

342
00:13:59,466 --> 00:14:01,566
which means it can be inferred by the compiler
可以被编译器所推断

343
00:14:02,100 --> 00:14:03,066
just like the type of a variable, we don't need to specify it explicitly
就像类型一样

344
00:14:03,066 --> 00:14:05,766
just like the type of a variable, we don't need to specify it explicitly
多数时候我们不需要去显示的指定类型

345
00:14:05,800 --> 00:14:08,533
the compiler can infer the type from the context
编辑器也可以推断出来

346
00:14:08,800 --> 00:14:11,466
but infer will be failed if multiple candidate types exist, 
但是当有多种类型都有可能时

347
00:14:11,700 --> 00:14:14,600
in such cases, we must explicitly specify the type of our variable
就需要显示的指定我们变量的类型了

348
00:14:16,000 --> 00:14:16,500
Similarly
类似的

349
00:14:16,500 --> 00:14:18,900
when lifetime could have different scopes
当生命周期可能有不同的范围时

350
00:14:19,466 --> 00:14:20,666
we have to specify the lifetime of a vairable explicitly
我们就必须显示的

351
00:14:20,666 --> 00:14:22,099
we have to specify the lifetime of a vairable explicitly
指定变量的生命周期

352
00:14:23,000 --> 00:14:23,933
Rust uses generic types to specify the relationship between lifetimes
在Rust里

353
00:14:23,933 --> 00:14:26,533
Rust uses generic types to specify the relationship between lifetimes
可以使用泛型参数来指定这种

354
00:14:26,533 --> 00:14:28,333
Rust uses generic types to specify the relationship between lifetimes
生命周期之间的关系

355
00:14:28,666 --> 00:14:30,366
it ensures the validity of the reference
来确保引用的有效性

356
00:14:31,800 --> 00:14:32,866
Here let's look at an example
这里我们来看一个例子

357
00:14:32,866 --> 00:14:35,133
we define a function called longest
我们定义了一个longest函数

358
00:14:35,600 --> 00:14:37,400
it has two parameters which are x and y
它有两个参数分别是x y

359
00:14:37,533 --> 00:14:39,399
both of the parameters are string slice
类型都是string slice

360
00:14:39,666 --> 00:14:42,099
the return value is also a string slice
返回值也是一个string slice

361
00:14:42,566 --> 00:14:43,599
the logic is pretty simple
它的逻辑很简单

362
00:14:43,600 --> 00:14:47,566
get the longer string in x, y and return it
返回x y里面更长的那一个字符串

363
00:14:48,766 --> 00:14:49,299
At this moment
这个时候

364
00:14:49,300 --> 00:14:51,466
there is no way for our compiler to infer the lifetime of the returned reference
我们编译器是没有办法推断出

365
00:14:51,466 --> 00:14:54,900
there is no way for our compiler to infer the lifetime of the returned reference
返回值对应的一个引用的生命周期

366
00:14:55,466 --> 00:14:57,466
we need to specify the lifetime explicitly
我们只能显示的指定

367
00:14:58,533 --> 00:14:59,566
By convention
约定俗成的

368
00:14:59,566 --> 00:15:01,666
we can use a lowercase letter and a ' in front as special generic type to identify the lifetime
我们使用小写字母

369
00:15:01,666 --> 00:15:03,099
we can use a lowercase letter and a ' in front as special generic type to identify the lifetime
前面加一个'

370
00:15:03,099 --> 00:15:03,100
we can use a lowercase letter and a ' in front as special generic type to identify the lifetime

371
00:15:03,100 --> 00:15:03,866
we can use a lowercase letter and a ' in front as special generic type to identify the lifetime
来表示

372
00:15:03,866 --> 00:15:06,266
we can use a lowercase letter and a ' in front as special generic type to identify the lifetime
我们的生命周期对应的泛型参数

373
00:15:06,666 --> 00:15:07,933
Here we have 'a as the generic type
这里我们定了一个'a

374
00:15:07,933 --> 00:15:09,333
Here we have 'a as the generic type
这样一个泛型参数

375
00:15:10,000 --> 00:15:11,333
and put 'a to the parameters x and y
并且把'a

376
00:15:11,333 --> 00:15:12,100
and put 'a to the parameters x and y

377
00:15:12,100 --> 00:15:15,200
and put 'a to the parameters x and y
对应的给到参数x和y

378
00:15:15,200 --> 00:15:18,000
it indicates that x and y have the same lifetime in the context of our function
表明x和y有相同的生命周期

379
00:15:18,900 --> 00:15:22,400
Similarly, we can also add 'a to the return value
同样的我们返回值也加一个'a的约束

380
00:15:23,200 --> 00:15:25,766
it indicates that the lifetime of our return value is as same as x and y
表示我们返回值的生命周期是和x y是一样的

381
00:15:25,766 --> 00:15:27,166
indicates that the lifetime of our return value is as same as x and y
表示我们返回值的生命周期是和x y是一样的

382
00:15:27,933 --> 00:15:29,733
Now our compiler can successfully compile
这样我们的编译器就可以成功的进行编译

383
00:15:29,733 --> 00:15:30,533
Now our compiler can successfully compile
这样我们的编译器就可以成功的进行编译

384
00:15:31,500 --> 00:15:34,066
Although here we don't know the exact lifetime of x, y
虽然在函数这里我们并不清楚x,y真正的生命周期

385
00:15:34,066 --> 00:15:35,466
Although here we don't know the exact lifetime of x, y
虽然在函数这里我们并不清楚x,y真正的生命周期

386
00:15:35,500 --> 00:15:36,933
actually we don't need to know the exact lifetime
其实也无需知道

387
00:15:36,933 --> 00:15:39,533
just be clear that at compile time
只要明白在实际运行时

388
00:15:39,766 --> 00:15:42,166
'a generic will be replaced with the one has the smaller lifetime among x and y
'a泛型会被替代为x y生命周期较小的那一个就可以了

389
00:15:42,166 --> 00:15:45,733
'a generic will be replaced with the one has the smaller lifetime among x and y
'a泛型会被替代为x y生命周期较小的那一个就可以了

390
00:15:47,166 --> 00:15:48,566
For the return value of function
对于函数的返回值

391
00:15:48,733 --> 00:15:51,733
the lifetime it referenced should comes from the parameters of function
它的引用的生命周期必须是来自参数

392
00:15:52,533 --> 00:15:53,899
think about it, if it's not from parameter
如果不是来自参数

393
00:15:53,900 --> 00:15:56,600
then it must comes from the function itself
那肯定是来自于函数本身

394
00:15:57,133 --> 00:15:59,799
since the variables defined inside the function will be cleared when function exits
由于函数内的变量在函数之外会被清空

395
00:15:59,799 --> 00:16:00,933
since the variables defined inside the function will be cleared when function exits
由于函数内的变量在函数之外会被清空

396
00:16:00,933 --> 00:16:02,366
this will lead to null pointer
所以会造成空指针

397
00:16:02,366 --> 00:16:05,766
In such cases, Rust compiler will not even let it go through
而这在Rust从根本上编译就不会通过

398
00:16:06,933 --> 00:16:10,466
Here we have defined a function named longest
这里我们定义了一个函数名称是longest

399
00:16:10,666 --> 00:16:14,699
it has two parameters x and y, the type is string slice
它有两个参数x y 分别是string slice类型

400
00:16:15,066 --> 00:16:17,266
the return value is also a string slice
返回值也是一个string slice

401
00:16:18,866 --> 00:16:21,533
it uses generic type 'a to specify the lifetime of our return value
我们通过一个泛型参数'a 来指定我们返回值的生命周期

402
00:16:21,533 --> 00:16:24,300
it uses generic type 'a to specify the lifetime of our return value
我们通过一个泛型参数'a 来指定我们返回值的生命周期

403
00:16:24,800 --> 00:16:25,466
here we can see
可以看到

404
00:16:25,466 --> 00:16:27,999
it defines a string in our function
我们函数里面定义了一个字符串

405
00:16:28,500 --> 00:16:32,300
then return the string slice referenced to the string
然后将字符串的string slice引用返回

406
00:16:32,566 --> 00:16:35,366
since the slice is referencing a value inside the function
由于我们引用了一个函数内的值

407
00:16:35,366 --> 00:16:37,366
the compilation will fail
所以我们的编译会失败

408
00:16:38,400 --> 00:16:39,600
Next let's take a look at the default rules of the reference's lifetime
接着我们来看一下

409
00:16:39,600 --> 00:16:41,800
Next let's take a look at the default rules of the reference's lifetime
引用类型的生命周期

410
00:16:41,933 --> 00:16:44,799
such rules are configured in the compiler
编译器所配置的一些缺省规则

411
00:16:45,266 --> 00:16:47,066
After use these rules
如果这一系列规则

412
00:16:47,533 --> 00:16:50,299
the lifetime of references can be determined
使用之后可以确定引用的生命周期

413
00:16:50,300 --> 00:16:51,900
then the generics of the lifetime
那我们对应的

414
00:16:51,900 --> 00:16:51,966
then the generics of the lifetime

415
00:16:51,966 --> 00:16:52,583
then the generics of the lifetime
生命周期的泛型参数就可以缺省

416
00:16:52,583 --> 00:16:53,866
can be defaulted
生命周期的泛型参数就可以缺省

417
00:16:54,266 --> 00:16:56,933
The first rule is that the compiler
第一个规则是编译器为每一个

418
00:16:57,600 --> 00:16:59,066
adds a generic to
引用类型的参数

419
00:16:59,066 --> 00:17:00,733
each reference parameter type
添加了生命周期的泛型

420
00:17:02,066 --> 00:17:03,866
For example, here we define a function foo
比如这里我们定义了一个foo函数

421
00:17:03,866 --> 00:17:05,566
it has two reference types
它有两个引用类型

422
00:17:06,200 --> 00:17:08,533
The compiler will automatically add
那编译器会自动给它加上

423
00:17:09,100 --> 00:17:10,600
two lifetime generics
两个生命周期泛型

424
00:17:10,600 --> 00:17:13,566
'a and 'b to different parameters respectively
'a和'b 分别是对应不同的参数

425
00:17:14,600 --> 00:17:15,533
The second rule is
第二规则是

426
00:17:15,533 --> 00:17:17,799
when there is only one lifetime generic
当生命周期泛型只有一个时

427
00:17:18,333 --> 00:17:20,466
the return values of all reference types
那所有引用类型的返回值

428
00:17:20,466 --> 00:17:22,933
will use this generic of this lifetime
都会使用这个生命周期的泛型

429
00:17:23,700 --> 00:17:25,266
For example, here we define a function foo
比如这里我们定了一个函数foo

430
00:17:25,366 --> 00:17:27,799
it has only one parameter x which is an application type
它只有一个参数x是一个引用类型

431
00:17:27,900 --> 00:17:29,600
its lifetime is 'a
那它的生命周期是'a

432
00:17:30,200 --> 00:17:32,366
Then the return value will just use 'a
那返回值会直接使用'a

433
00:17:32,366 --> 00:17:34,066
as its lifetime
这样的一个生命周期

434
00:17:35,366 --> 00:17:36,199
The third rule is
第三个规则是

435
00:17:36,200 --> 00:17:38,066
when there are multiple lieftime generics
生命周期的泛型有多个时

436
00:17:38,500 --> 00:17:40,333
and one of them is
并且其中一个是

437
00:17:40,566 --> 00:17:43,199
self reference or mutable reference
自身的引用或者可变的引用

438
00:17:43,400 --> 00:17:46,133
then the return value of all references
那么所有引用类型的返回值

439
00:17:46,166 --> 00:17:47,333
will use
都会使用

440
00:17:47,400 --> 00:17:49,866
the lifetime of this self-referenced lifetime
这样一个自身引用对应的生命周期

441
00:17:49,866 --> 00:17:51,599
For example, here we define a function foo
比如这里我们定义了一个函数foo

442
00:17:51,766 --> 00:17:54,799
it has two parameters one is self reference
它有两个参数一个是self的引用

443
00:17:54,966 --> 00:17:57,499
The other one is the I32 reference
另外一个是i32引用

444
00:17:57,666 --> 00:17:59,866
Respectively the compiler will add 
分别编译器会增加一个

445
00:18:00,000 --> 00:18:01,666
lifetime generics 'a and 'b
生命周期的泛型参数

446
00:18:01,666 --> 00:18:01,933
lifetime generics 'a and 'b

447
00:18:01,933 --> 00:18:02,799
lifetime generics 'a and 'b
'a和'b

448
00:18:03,100 --> 00:18:04,166
Then the return value
那我们返回值的话

449
00:18:04,166 --> 00:18:06,199
will use the lifetime of the self reference
会使用self引用的生命周期

450
00:18:06,200 --> 00:18:07,266
that is 'a
也就是'a

451
00:18:08,866 --> 00:18:09,933
Partial fields of the structure
结构体的部分字段

452
00:18:09,933 --> 00:18:11,399
can also be a reference to a value
也可以是某个值的引用

453
00:18:11,400 --> 00:18:13,400
We shall specify
那这个时候我们就要指定

454
00:18:13,466 --> 00:18:14,966
reference lifetime
引用的生命周期

455
00:18:15,133 --> 00:18:16,399
and noted that
并且需要注意的是

456
00:18:16,400 --> 00:18:17,700
the instance of the structure
结构体的实例

457
00:18:17,900 --> 00:18:21,866
is no longer available outside the scope of the value
在该值的作用域之外就不再可用了

458
00:18:22,266 --> 00:18:22,599
For example
比如这里

459
00:18:22,600 --> 00:18:24,733
we define a struct summary 
我们定义了一个Summary的结构体

460
00:18:24,733 --> 00:18:26,199
one of its attributes part is a reference to a string slice
它的一个属性part

461
00:18:26,199 --> 00:18:26,700
one of its attributes part is a reference to a string slice

462
00:18:26,700 --> 00:18:29,133
one of its attributes part is a reference to a string slice
是一个string slice的引用

463
00:18:30,100 --> 00:18:32,166
So here we have to specify its lifetime is 'a
那么这里我们要指定它的生命周期

464
00:18:32,166 --> 00:18:32,866
So here we have to specify its lifetime is 'a
是'a

465
00:18:32,866 --> 00:18:35,933
When we define a string "text" in the main function
当我们在main函数里面定了一个

466
00:18:35,933 --> 00:18:36,000
When we define a string "text" in the main function

467
00:18:36,000 --> 00:18:37,200
When we define a string "text" in the main function
字符串text

468
00:18:37,300 --> 00:18:38,733
and get its
并且获取它的

469
00:18:39,300 --> 00:18:41,133
first sentence, it's a string slice
第一个句子first sentence

470
00:18:41,133 --> 00:18:41,300
first sentence, it's a string slice

471
00:18:41,300 --> 00:18:42,700
first sentence, it's a string slice
它是一个string slice

472
00:18:43,300 --> 00:18:45,266
Then construct a summary struct
然后构造一个summary结构体

473
00:18:45,266 --> 00:18:48,099
assign the value of first sentence to part
把first_sentence赋值给part

474
00:18:48,266 --> 00:18:51,133
After our first sentence exits the scope
当我们的first_sentence退出作用域之后

475
00:18:51,133 --> 00:18:53,533
then our struct summary will no longer be available
那我们的结构体summary也就不再可用

476
00:18:54,333 --> 00:18:56,133
In another situation,
另外一个生命周期里

477
00:18:56,133 --> 00:18:58,599
we will always meet static lifetime
经常会遇到的概念是静态生命周期

478
00:18:58,600 --> 00:19:01,666
Static means
static 他所表示的意思是

479
00:19:01,666 --> 00:19:03,499
it is valid
当前的引用的有效性

480
00:19:03,500 --> 00:19:06,366
throughout the whole execution cycle of the program
是在整个程序的执行周期

481
00:19:06,533 --> 00:19:07,599
That is to say
也就是说

482
00:19:07,766 --> 00:19:10,899
this reference will remain valid until the program exits
该引用会一直有效直到程序退出

483
00:19:11,400 --> 00:19:15,466
string literal,  the string enclosed in double quotes
string literal 也就是用双引号括起来的

484
00:19:15,466 --> 00:19:17,733
are static by default
字符串字面量是static的

485
00:19:17,933 --> 00:19:21,133
it can be identified by 'static
可以通过'static来标识

486
00:19:21,533 --> 00:19:25,399
We need to use the static lifetime carefully
我们需要谨慎的使用static生命周期

487
00:19:25,966 --> 00:19:28,133
When there is a null pointer in the code or
当代码里存在空指针或者

488
00:19:28,500 --> 00:19:30,333
when the lifetime of the reference does not match
引用的生命周期不匹配的时候

489
00:19:30,333 --> 00:19:32,133
the compiler often reports compilation errors
编译器经常会报编译错误

490
00:19:32,133 --> 00:19:35,566
and it will recommended us to use static static lifetime
并且建议我们使用static静态生命周期

491
00:19:35,566 --> 00:19:37,066
But at this time we have to consider
但这个时候我们要考虑一下

492
00:19:37,066 --> 00:19:39,366
do we really want our references
我们是否是真的希望我们的引用

493
00:19:39,466 --> 00:19:41,499
to be valid all the time in the program
在程序的全局是有效的

494
00:19:41,566 --> 00:19:42,266
If not
如果不是的话

495
00:19:42,266 --> 00:19:44,766
we need to fix our null pointer and
我们就需要去修复我们的空指针和

496
00:19:45,100 --> 00:19:46,966
bugs like lifetime mismatch
生命周期不匹配这样的一个bug

497
00:19:46,966 --> 00:19:49,499
instead of using the static lifetime
而不是去使用static生命周期

498
00:19:49,500 --> 00:19:51,333
Today's course content is over here
今天课程内容到这里就结束了

499
00:19:51,333 --> 00:19:52,133
thank you all
谢谢大家

